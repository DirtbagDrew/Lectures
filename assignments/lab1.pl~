:- use_module(library(clpfd)).

% Andrew Myer 012939730
% CECS 424 Lab 1
% 9/27/18
%-------------------------------------------------------------
% sum_list([],Sum)
% finds the sum of the list by adding the head of the list and
% then iterating the next value in the list to be the head
% base case: the sum of the empty list is 0
% []:the list of cells to add
% Sum:the resulting sum of the list
get_value([X,Y],S,Z):-
        nth0(Y,S,Row),
        nth0(X,Row,Z).

sum_list([],S,0).
sum_list([Head|Tail],S,Sum) :-
        sum_list(Tail,S,Tsum),
        get_value(Head,S,Z),
        Sum #= Z + Tsum.
%-------------------------------------------------------------
% product_list([],product)
% multiplies all the values of the list together by multiplying
% the head of the list and iterating the next value as the value
% to multiply to the head.
% base case: with an empty list, although it doesnt make sense
% right now, for our purposes its 1
% []:the list of cells to multiply against eachother
% Product: the resulting product of the list
product_list([],S,1).
product_list([Head|Tail],S,Product) :-
        product_list(Tail,S,Tproduct),
        get_value(Head,S,Z),
        Product #= Z * Tproduct.
%--------------------------------------------------------------
% cell values
% assigns values to coordinates in a cell.
% base case: empty lists, do nothing
cell_values([],_,[]).
cell_values([[Coordheadx,Coordheady]|Coordtail],S, [Valuehead|Valuetail]):-
        nth0(Coordheady,S,Y),
        nth0(Coordheadx,Y,Valuehead),
        cell_values(Coordtail,S,Valuetail).
%--------------------------------------------------------------
% check constraint(cage(method, Value, Cells), S)
% checks if the value for the cage is the value of the cell
% cage: a box of cells that follows a specidied rule
% method: the method to which the cage will be checked to
% Value: the number to which the rule should result in
% Cells: the coordinates that the cage contains

% method = id:the cell in the cage will equal the Value
check_constraint(cage(id, Value, Cells), S):-
        cell_values(Cells,S,Value).
% method = add:the values of cells will all add up to the Value
check_constraint(cage(add, Value,Cells), S):-
        sum_list(Cells,S,X),
        X#=Value.
% method = sub:the values in the cells will subtract to the Value.
check_constraint(cage(sub, Value, [Cell1,Cell2]), S):-
        get_value(Cell1,S,C1),
        get_value(Cell2,S,C2),
        C1-C2#=Value;C2-C1#=Value.
% method = mult:values in the cells will multiply to Value
check_constraint(cage(mult, Value, Cells), S):-
        product_list(Cells,S,X),
        X#=Value.
% method = div: values in the cell will divide to Value
check_constraint(cage(div, Value, [Cell1,Cell2]), S):-
       get_value(Cell1,S,C1),
       get_value(Cell2,S,C2),
       X #= div(C1,C2),
       Y #= div(C2,C1),
       X #= Value; Y #= Value.
%---------------------------------------------------------------
%check_cages([Cages])
%uses check constraints to apply rules to all cages
%Cages: list of all cages in the game
check_cages([],_).
check_cages([CageHead|CageTail],S):-
       check_constraint(CageHead,S),
       check_cages(CageTail,S).
row_size([],_).
row_size([H|T],N):-
        length(H,N),
        row_size(T,N).
col_size(S,N):-
        length(S,N).
%---------------------------------------------------------------
kenken(Puzzle,Cages):-
        col_size(Puzzle,6),
        row_size(Puzzle,6),
        append(Puzzle, Values),
	Values ins 1..6,
        check_cages(Cages,Puzzle),
        maplist(all_different, Puzzle),
        transpose(Puzzle, Cols),
        maplist(all_different, Cols),
        maplist(label, Puzzle).
        /*
        A=[A1,A2,A3,A4,A5,A6],
        B=[B1,B2,B3,B4,B5,B6],
        C=[C1,C2,C3,C4,C5,C6],
        D=[D1,D2,D3,D4,D5,D6],
        E=[E1,E2,E3,E4,E5,E6],
        F=[F1,F2,F3,F4,F5,F6],

        Co1=[A1,B1,C1,D1,E1,F1],
        Co2=[A2,B2,C2,D2,E2,F2],
        Co3=[A3,B3,C3,D3,E3,F3],
        Co4=[A4,B4,C4,D4,E4,F4],
        Co5=[A5,B5,C5,D5,E5,F5],
        Co6=[A6,B6,C6,D6,E6,F6],

        A ins 1..6,
        B ins 1..6,
        C ins 1..6,
        D ins 1..6,
        E ins 1..6,
        F ins 1..6,
        %check_constraint(cage(add,11,[[0,0],[0,1]]),Puzzle).



        check_cages(Cages,Puzzle),
        all_different(A),
        all_different(B),
        all_different(C),
        all_different(D),
        all_different(E),
        all_different(F),

        all_different(Co1),
        all_different(Co2),
        all_different(Co3),
        all_different(Co4),
        all_different(Co5),
        all_different(Co6),
        */

        %nth0(1,Puzzle,D),
        %nth0(1,D,E),
        %label(D).
        %cell_values([[1,1]],Puzzle,[2]),
                %sum_list([[1,1],[0,1]],Puzzle,Sum),
        %Sum#=4,

     % ,Puzzle=[[_,_,_,_,_,_],[_,_,_,_,_,_],[_,_,_,_,_,_],[_,_,_,_,_,_],[_,_,_,_,_,_],[_,_,_,_,_,_]],Puzzle=[A,B,C,D,E,F],kenken([A,B,C,D,E,F]).
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
